diff --git a/express/Expr.cpp b/express/Expr.cpp
index 6e5ac56..48a863d 100644
--- a/express/Expr.cpp
+++ b/express/Expr.cpp
@@ -37,6 +37,52 @@ static bool HasUnknownDim(const std::vector<int>& dims) {
 
 namespace MNN {
 namespace Express {
+VARP::VARP() noexcept {
+}
+VARP::~VARP() noexcept {
+}
+VARP::VARP(std::shared_ptr<Variable> c) {
+    mContent = std::move(c);
+}
+VARP::VARP(Variable* c) {
+    mContent.reset(c);
+}
+Variable* VARP::get() const {
+    return mContent.get();
+}
+VARP::VARP(const VARP& var) {
+    mContent = var.mContent;
+}
+VARP::VARP(VARP&& var) {
+    mContent = std::move(var.mContent);
+}
+bool VARP::operator==(const VARP& var) const {
+    return var.mContent == mContent;
+}
+bool VARP::operator<(const VARP& var) const {
+    return mContent < var.mContent;
+}
+bool VARP::operator<=(const VARP& var) const {
+    return mContent <= var.mContent;
+}
+VARP& VARP::operator=(const VARP& var) {
+    mContent = var.mContent;
+    return *this;
+}
+VARP& VARP::operator=(Variable* var) {
+    mContent.reset(var);
+    return *this;
+}
+Variable* VARP::operator->() const {
+    return mContent.get();
+}
+bool operator==(Variable* src, VARP dst) {
+    return src == dst.get();
+}
+bool operator!=(Variable* src, VARP dst) {
+    return src != dst.get();
+}
+
 void Variable::Info::syncSize() {
     size = 1;
     for (int i=0; i<dim.size(); ++i) {
diff --git a/include/MNN/expr/Expr.hpp b/include/MNN/expr/Expr.hpp
index 5cd0859..33d05f0 100644
--- a/include/MNN/expr/Expr.hpp
+++ b/include/MNN/expr/Expr.hpp
@@ -32,27 +32,13 @@ typedef std::vector<int> INTS;
 enum Dimensionformat { NHWC, NC4HW4, NCHW };
 class MNN_PUBLIC VARP {
 public:
-    VARP() {
-        // Do nothing
-    }
-    VARP(std::shared_ptr<Variable> c) {
-        mContent = std::move(c);
-    }
-    VARP(Variable* c) {
-        mContent.reset(c);
-    }
-    Variable* get() const  {
-        return mContent.get();
-    }
-    ~ VARP() {
-        // Do nothing
-    }
-    VARP(const VARP& var) {
-        mContent = var.mContent;
-    }
-    VARP(VARP&& var) {
-        mContent = std::move(var.mContent);
-    }
+    VARP() noexcept;
+    VARP(std::shared_ptr<Variable> c);
+    VARP(Variable* c);
+    Variable* get() const;
+    ~VARP() noexcept;
+    VARP(const VARP& var);
+    VARP(VARP&& var);
     VARP operator+(VARP var) const;
     VARP operator-(VARP var) const;
     VARP operator*(VARP var) const;
@@ -60,26 +46,12 @@ public:
     VARP mean(INTS dims) const;
     VARP sum(INTS dims) const;
 
-    bool operator==(const VARP& var) const {
-        return var.mContent == mContent;
-    }
-    bool operator<(const VARP& var) const {
-        return mContent < var.mContent;
-    }
-    bool operator<=(const VARP& var) const {
-        return mContent <= var.mContent;
-    }
-    VARP& operator=(const VARP& var) {
-        mContent = var.mContent;
-        return *this;
-    }
-    VARP& operator=(Variable* var) {
-        mContent.reset(var);
-        return *this;
-    }
-    Variable* operator->() const  {
-        return mContent.get();
-    }
+    bool operator==(const VARP& var) const;
+    bool operator<(const VARP& var) const;
+    bool operator<=(const VARP& var) const;
+    VARP& operator=(const VARP& var);
+    VARP& operator=(Variable* var);
+    Variable* operator->() const;
     enum InputType {
         INPUT = 0,
         CONSTANT = 1,
@@ -90,12 +62,9 @@ private:
     friend class Variable;
     std::shared_ptr<Variable> mContent;
 };
-inline bool operator==(Variable* src, VARP dst) {
-    return src == dst.get();
-}
-inline bool operator!=(Variable* src, VARP dst) {
-    return src != dst.get();
-}
+
+MNN_PUBLIC bool operator==(Variable* src, VARP dst);
+MNN_PUBLIC bool operator!=(Variable* src, VARP dst);
 // inline bool operator<(VARP src, VARP dst) {
 //     return src.get() < dst.get();
 // }
diff --git a/source/utils/InitNet.hpp b/source/utils/InitNet.hpp
index 950eed0..c07f58c 100644
--- a/source/utils/InitNet.hpp
+++ b/source/utils/InitNet.hpp
@@ -12,11 +12,11 @@
 
 namespace MNN {
 // init Tensors by net
-bool initTensors(std::vector<std::shared_ptr<Tensor>>& allTensors, const Net* net);
+MNN_PUBLIC bool initTensors(std::vector<std::shared_ptr<Tensor>>& allTensors, const Net* net);
 // init Pipeline Infos by oplist and tensors
-void initPipelineInfosFromOps(std::vector<Schedule::PipelineInfo>& infos, std::vector<const Op*>& ops, const std::vector<std::shared_ptr<Tensor>>& allTensors);
+MNN_PUBLIC void initPipelineInfosFromOps(std::vector<Schedule::PipelineInfo>& infos, std::vector<const Op*>& ops, const std::vector<std::shared_ptr<Tensor>>& allTensors);
 // set input and output for allTensors by ops info
-void setInputOutputForOps(std::vector<std::shared_ptr<Tensor>>& allTensors, const std::vector<const Op*>& ops, bool isStatic = false);
+MNN_PUBLIC void setInputOutputForOps(std::vector<std::shared_ptr<Tensor>>& allTensors, const std::vector<const Op*>& ops, bool isStatic = false);
 // init Pipeline Infos by net and tensors, set input and output info
-void initPipelineInfosFromNet(std::vector<Schedule::PipelineInfo>& infos, const Net* net, std::vector<std::shared_ptr<Tensor>>& allTensors);
+MNN_PUBLIC void initPipelineInfosFromNet(std::vector<Schedule::PipelineInfo>& infos, const Net* net, std::vector<std::shared_ptr<Tensor>>& allTensors);
 } // namespace MNN
